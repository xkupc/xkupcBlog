---
title: 并发编程里的一些概念（一）
date: 2017-10-09 16:06:56
tags: [java]
categories: java base
---
## 前言
前阵子，研究了一下分布式唯一ID的生成方法，接触了多线程的一些东西，发现自己对并发编程的一些基础概念还是一无所知，对于并发的控制还是停留在synchronized的层面，简直不能再低级了，小编可是要成为架构师的男人，怎么可以如此堕落。于是可劲各种谷歌了。今天做一点基础的入门笔记，简单介绍一下多线程编程里的一些概念。
## 线程的实现
从最基本的开始，我们知道线程最基本的实现有两种。实现Runable接口和继承Thread重写run方法。
<!--more-->
```
public class MyThread1 extends Thread {

    public void run() {
        System.out.println("this is myThread1");
    }
}
public class MyThread2 implements Runnable{
    public void run() {
        System.out.println("this is myThread2");
    }
}

@Test
    public void threadTest() {
        Thread thread1 = new MyThread1();
        Thread thread2 = new Thread(new MyThread2());
        thread1.start();
        thread2.start();
    }

```
在JDK1.5后我们有第三种方法实现，那就是实现Callable接口,Callable和Runable区别主要是Callable的call方法有返回值同时能抛出异常，而Runable的run方法没有。同时运行Callable任务能够拿到一个Future对象，通过Future对象我们可以检查任务是否完成，检索任务执行的结果，同时可以取消任务的执行，弥补了Thread的不足。
Callable无法通过new Thread(Runable r)来实现。通常我们可以通过FutureTask来实现，FutureTask实现了Runnable和Future，使得我们依旧能通过Thread启动线程。
```
public class MyThread3 implements Callable<Boolean> {
    public Boolean call() throws Exception {
        System.out.println("this is myThread3");
        return true;
    }
}
@Test
    public void threadTest() {
        Thread thread1 = new MyThread1();
        Thread thread2 = new Thread(new MyThread2());
        FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new MyThread3());
        Thread thread3 = new Thread(futureTask);
        thread1.start();
        thread2.start();
        thread3.start();
    }
```
当然我们也可以通过ExecutorService来实现，ExecutorService是线程池里一个概念。我们接着看看线程池的实现。
## 线程池的实现
在java 5之后，java.util.concurrent里提供了现成的线程池的实现。这个包里的线程的类图：
![Executor](/images/thread/Executor.png)
看看相关的源码：
```
public interface Executor {
    void execute(Runnable command);
}

public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();

    boolean isShutdown();
    boolean isTerminated();

    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);
    ...
}

public class Executors {
    public static ExecutorService newCachedThreadPool() {
            return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, 
                            new SynchronousQueue<Runnable>());
    }
    ...
}
```
可以看到ExecutorService通过继承Executor定义了一个线程池，默认线程池实现是ThreadPoolExecutor。我们可以通过Executors创建线程池。
Executors里提供了四种线程池的实现。
```
newFixedThreadPool(int nThreads);

newSingleThreadExecutor();


```
